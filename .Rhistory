install.packages(c("dvetools", "roxygen2", "testthat", "knitr"))
install.packages("restudioapi")
install.packages("rstudioapi")
rstudioapi::isAvailable()
rstudioapi::isAvailable("0.99.149")
has_devel
devtools::has_devel()
2**3
2**4
getwD()
getwd()
devtools::load_all()
devtools::load_all()
devtools::load_all()
p <- 30
n <- 100
n <- 100
n <- 100
n <- 100
p <- 30
x <- matrix(rnorm(n*p), nrow = n, ncol = p)
x <- abs(matrix(rnorm(n*p), nrow = n, ncol = p))
y <- x[,1] + rnorm(n)
y <- x[,1] + rnorm(n)
y <- x[, 1] - x[, 2]+ rnorm(n)
y <- y - mean(y)
fit1 <- glmnet.constr(x, y, family = "gaussian")
fit1$beta
cv.fit1 <- cv.glmnet.constr(fit1 x, y)
cv.fit1 <- cv.glmnet.constr(fit1, x, y)
cv.fit1$lambda
cv.fit1$cvm
predict.glmnet.constr(fit1, x)
pred <- predict.glmnet.constr(fit1, x)
dim(pred)
cv_two_stage(log(1 + x), y)
two_stage(log(1 + x), y)
x <- log(1 + abs(matrix(rnorm(n*p), nrow = n, ncol = p))
y <- x[, 1] - x[, 2]+ rnorm(n)
y <- y - mean(y)
fit1 <- glmnet.constr(x, y, family = "gaussian")
fit1$beta
cv.fit1 <- cv.glmnet.constr(fit1, x, y)
cv.fit1$cvm
pred <- predict.glmnet.constr(fit1, x)
two_stage(log(1 + x), y)
x <- log(1 + abs(matrix(rnorm(n*p), nrow = n, ncol = p)))
n <- 100
n <- 100
n <- 100
n <- 100
p <- 30
x <- log(1 + abs(matrix(rnorm(n*p), nrow = n, ncol = p)))
y <- x[, 1] - x[, 2]+ rnorm(n)
y <- y - mean(y)
fit1 <- glmnet.constr(x, y, family = "gaussian")
fit1$beta
cv.fit1 <- cv.glmnet.constr(fit1, x, y)
cv.fit1$cvm
pred <- predict.glmnet.constr(fit1, x)
two_stage(log(1 + x), y)
fit1 <- glmnet.constr(x, y, family = "gaussian", lambda_1 = exp(-1:n))
n
two_stage(log(1 + x), y, lamba_1 = exp(-1:5))
two_stage(log(1 + x), y, lambda_1 = exp(-1:5))
two_stage(log(1 + x), y, lambda_1 = exp(1:5))
two_stage(log(1 + x), y, lambda_1 = exp(-1 * 1:5))
two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
library(devtools)
load_all()
two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts$coef
ts$selected
ts$coef
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
load_all()
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-4))
cv_ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-6))
cv_ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
out_to_beta()
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts
out_to_beta(ts$coef[[10]])
out_to_beta(ts$coef[[10]], 30, 2)
ts$coef[[10]]
load_all()
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-4))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-8))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-5))
cv_ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-6))
cv_ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
which.min(c(1,2,3), arr.ind = T)
which.min(c(1,2,3), arr.ind = TRUE)
which(c(1,2,3) == 2, arr.ind = TRUE)
? which
? which
load
load_all()
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
a <- matrix(c(1,2,3,4), nrow = 2)
which(a == 2)
which(a == 2, arr.ind = TRUE)
load_all()
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-4))
ts
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-7))
ts
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-8))
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-9))
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
load_all()
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
ts
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
load_all
load_all()
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
out_to_beta(NA, k = 5, p = 30)
load_all
load_all()
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
out_to_beta(NA, k = 5, p = 30)
print(5)
load_all
load_all()
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
load_all()
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts$coef[[1]]
ts$coef[[2]]
ts$coef[[7]]
ts$coef[[8]]
ts$coef[[9]]
ts$coef[[10]]
load_all()
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-7))
cv_ts$beta_min
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts$beta_min
cv_ts$mse
n <- 100
p <- 30
x <- log(1 + abs(matrix(rnorm(n*p), nrow = n, ncol = p)))
y <- x[, 1] - x[, 2] + .001 * rnorm(n)
y <- y - mean(y)
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts
cv_ts$mse
cv_ts$best
load_all
load_all()
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts$best
mse
cv_ts$mse
y <- x[, 1] - x[, 2] + .1 * rnorm(n)
y <- y - mean(y)
fit1 <- glmnet.constr(x, y, family = "gaussian")
fit1$beta
cv.fit1 <- cv.glmnet.constr(fit1, x, y)
cv.fit1$cvm
pred <- predict.glmnet.constr(fit1, x)
ts <- two_stage(log(1 + x), y, lambda_1 = exp(0:-10))
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts$best
cv_ts
cv_ts$mse
cv_ts$two_step_obj
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10), second.stage = "yhat")
cv_ts$mse
cv_ts
cv_ts <- cv_two_stage(x, y, lambda_1 = exp(0:-10))
cv_ts
load_all()
cv.approximate_fs(z,y,k_max = 5)
afs <- cv.approximate_fs(x,y,k_max = 5)
afs
afs$cvm
getwr()
getwd()
library(devtools)
library(logratio)
devtools::document()
? glmnet.constr
document()
? document
? glmnet.constr
devtools::use_vignette("simple-example")
? scale
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
model_fit$beta
model_fit$beta
summary(model_fit$beta)
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
load_all()
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$beta
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(w, y, k_max = 5)
ts_model$betas
ts_model$betas[[50]]
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(w, y, k_max = 5)
ts_model$betas[[50]]
set.seed(1)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(w, y, k_max = 5)
ts_model$betas[[50]]
set.seed(10)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(w, y, k_max = 5)
ts_model <- two_stage(w, y, k_max = 5)
ts_model$betas[[50]]
cv_ts_model <- cv_two_stage(w, y, k_max = 5)
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p),nrow = n))
y <- rbinom(n, 1, .5)
model2 <- glmnet.constr(x, y, family = "binomial")
cv_model2 <- cv.glmnet.constr(model2, x, y)
load_all()
cv_model2 <- cv.glmnet.constr(model2, x, y)
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p),nrow = n))
y <- rbinom(n, 1, .5)
model2 <- glmnet.constr(x, y, family = "binomial")
cv_model2 <- cv.glmnet.constr(model2, x, y)
load_all()
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p),nrow = n))
y <- rbinom(n, 1, .5)
model2 <- glmnet.constr(x, y, family = "binomial")
cv_model2 <- cv.glmnet.constr(model2, x, y)
load_all
load_all()
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p),nrow = n))
y <- rbinom(n, 1, .5)
model2 <- glmnet.constr(x, y, family = "binomial")
cv_model2 <- cv.glmnet.constr(model2, x, y)
load_all()
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p),nrow = n))
y <- rbinom(n, 1, .5)
model2 <- glmnet.constr(x, y, family = "binomial")
cv_model2 <- cv.glmnet.constr(model2, x, y)
cv_model2$cvm
dim(model2$cvm)
set.seed(1)
n <- 100
p <- 30
x <- abs(matrix(rnorm(n*p),nrow = n))
y <- x[, 1] + x[, 2] + .1 * rnorm(n)
y <- y - mean(y)
model <- glmnet.constr(x, y, family = "gaussian")
cv_model <- cv.glmnet.constr(model, x, y)
cv_model$cvm
errfun=function(yhat,y){
eps=1e-4
pr=1/(1+exp(-yhat))
o=( y==1 & (pr>1-eps) ) | (y==0 & (pr<eps))
val=y*log(pr)+(1-y)*log(1-pr)
val = val -2*mean(val[!o])
}
errfun(c(.5,.5), c(1,0))
errfun(c(.5,.5), c(1,0))
errfun(5,5)
errfun=function(yhat,y){
eps=1e-4
pr=1/(1+exp(-yhat))
o=( y==1 & (pr>1-eps) ) | (y==0 & (pr<eps))
val=y*log(pr)+(1-y)*log(1-pr)
val = val -2*mean(val[!o])
val
}
errfun(c(.5,.5), c(1,0))
errfun=function(yhat,y){
eps=1e-4
pr=1/(1+exp(-yhat))
o=( y==1 & (pr>1-eps) ) | (y==0 & (pr<eps))
val=y*log(pr)+(1-y)*log(1-pr)
-2*mean(val[!o])
}
errfun(c(.5,.5), c(1,0))
errfun(c(.5,.5), c(1,0))
errfun(c(.75,.5), c(1,0))
errfun(c(.75,.25), c(1,0))
errfun(c(.75,.001), c(1,0))
errfun(c(.99,.001), c(1,0))
load_all
load_all()
set.seed(10)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(w, y, k_max = 5)
ts_model <- two_stage(w, y, k_max = 5)
ts_model$betas[[50]]
cv_ts_model <- cv_two_stage(w, y, k_max = 5)
cv_ts_model$best_params
cv_ts_model$lambda_min
cv_ts_model$k_min
cv_ts_model$lambda
cv_ts_model$beta_min
ts_model <- two_stage(centered_w, centered_y, k_max = 5)
ts_model$betas[[50]]
cv_ts_model <- cv_two_stage(centered_w, centered_y, k_max = 5)
cv_ts_model$lambda_min #index of best lambda
cv_ts_model$k_min #number of ratios
cv_ts_model$beta_min
cv_ts_model$beta_min
cv_ts_model$k_min #number of ratios
cv_ts_model$lambda_min #index of best lambda
cv_ts_model$k_min #number of ratios
cv_ts_model$beta_min
cv_two_stage(centered_w, centered_y, k_max = 5, second_stage = "yhat")
cv_ts_model2 <- cv_two_stage(centered_w, centered_y, k_max = 5, second_stage = "yhat")
cv_ts_model2$beta_min
cv_ts_model2 <- cv_two_stage(centered_w, centered_y, k_max = 5, second_stage = "yhat")
cv_ts_model2$beta_min
cv_ts_model2 <- cv_two_stage(centered_w, centered_y, k_max = 5, second.stage = "yhat")
cv_ts_model2$beta_min
cv_ts_model$best_params
cv_ts_model$beta_min
set.seed(10)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(centered_w, centered_y, k_max = 5)
ts_model$betas[[50]]
cv_ts_model <- cv_two_stage(centered_w, centered_y, k_max = 5)
cv_ts_model$lambda_min #index of best lambda
cv_ts_model$k_min #number of ratios
cv_ts_model$beta_min
cv_ts_model2 <- cv_two_stage(centered_w, centered_y, k_max = 5, second.stage = "yhat")
cv_ts_model2$beta_min
library(logratio)
set.seed(10)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
ts_model <- two_stage(centered_w, centered_y, k_max = 5)
load_all()
plot(1:10)
plot(10:1)
knitr::kable(head(mtcars, 10))
library(logratio)
set.seed(10)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(centered_w, centered_y, k_max = 5)
ts_model$betas[[50]]
cv_ts_model <- cv_two_stage(centered_w, centered_y, k_max = 5)
cv_ts_model$lambda_min #index of best lambda
cv_ts_model$k_min #number of ratios
cv_ts_model$beta_min
cv_ts_model2 <- cv_two_stage(centered_w, centered_y, k_max = 5, second.stage = "yhat")
cv_ts_model2$beta_min
load_all()
library(logratio)
set.seed(10)
n <- 100 #number of observations
p <- 20 #number of features
x <- abs(matrix(rnorm(n*p), nrow = n)) #positive raw features
w <- log(x) #logarithmically transformed features
y <- w[, 1] - w[, 2] + rnorm(n) #response
centered_w <- scale(w, center = TRUE, scale = FALSE)
centered_y <- y - mean(y)
model_fit <- glmnet.constr(centered_w, y, family = "gaussian")
dim(model_fit$beta)
cv_model_fit <- cv.glmnet.constr(model_fit, x, y)
cv_model_fit$cvm #CV estimate of error
cv_model_fit$beta #best beta value
ts_model <- two_stage(centered_w, centered_y, k_max = 5)
ts_model$betas[[50]]
cv_ts_model <- cv_two_stage(centered_w, centered_y, k_max = 5)
cv_ts_model$lambda_min #index of best lambda
cv_ts_model$k_min #number of ratios
cv_ts_model$beta_min
cv_ts_model2 <- cv_two_stage(centered_w, centered_y, k_max = 5, second.stage = "yhat")
cv_ts_model2$beta_min
afs_model <- approximate_fs(w, y, k_max = 10)
afs_model$beta
afs_model$beta
afs_model <- approximate_fs(w, y, k_max = 5)
afs_model$beta
